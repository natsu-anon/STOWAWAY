All messages use "#### STOWAWAY #### (maybe some meme about the version or linking the github)" now.
All messages attach stowaway.json
NOTE: encrypted is encrypted.  Clearly.  But I need to write about what's in there.

SENDING A MESSAGE:
json:
{
	type: 'channel_message',
	encrypted: { <= SIGN THIS BIT
		fingerprints: [ fingerprints of public keys used to send this message ]
		plainText: the message itself.
	}
}

then when message recieved:
1. get stowaway.json
2. see if type == message
3. attempt to decrypte encrypted
4. if successful:
  a. verify message signature (if not verified add a warning -- protects against token compromise)
  b. display message
  c. if old key in fingerprint respond with current key provenance protocol from fingerprinted key


HANDSHAKE REQUEST:
json:
{
	type: 'handshake_request',
	publicKey: armored public key
}

HANDHSAKE RESPONSE:
json:
{
	type: 'handhsake_response'
	publicKey: armored public key
}

then when message recieved
1. get attached json & check type
2. old handhsake protocol with publicKey value

KEY SIGNATURE:
NOTE: signer doesn't update his own keys, only after receiving KEY UPDATE does anyone (aside from recipient) update their public keys
json:
{
	type: 'signed_key'
	recipient: snowflake of intended recipient
	publicKey: signed key
}

recipient still checks if fingerprints match, and if they do (1) update then:

KEY UPDATE (send this to all known channels):
json:
{
	type: 'key_update'
	publicKey: update public key
}
again, perform the fingerprint check then use update.  It gracefully merges keys if they have the same fingerprint.

REVOCATION PROTOCOL (send this to all known channels):
- NOTE SAVE OLD PUBLIC KEYS & REVOKED KEYS -- USED IN KEY PROVENANCE
json:
{
	type: 'revocation'
	revocation: the revoked key (see pgp-features-test.js -- should be signed by the new private key)
	publicKey: new public key
}

etc.

PROVENANCE PROTOCOL (happens when you notice sending you a message with some compromised keys)

json:
{
	type: 'partial_provenance'
	recipient: snowflake of intended recipient
	order: [
		{
			revocation: revoked key that matches old fingerprint
			publicKey: new public key that signed the revokedKey
		},
		etc. until:
		{
			revocation: revoked key that matches previous key fingerprint
			publicKey: current public key that signed the last revokedKey
		}
	]
}

json:
{
	type: 'full_provenance',
	recipient: snowflake of intended recipient
	firstKey: first public key
	order: [
		{
			revocation: revoked key that matches old fingerprint
			publicKey: public key that signed the revokedKey
		},
		etc. until:
		{
			revocation: revoked key that matches previous key fingerprint
			publicKey: current public key that signed the last revokedKey
		}
	]
}

can also request a key provenance via:
json:
{
	type: 'provenance_request'
	recipient: id of intended recipient
	fingerprint: fingerprint of (sender's) current public key for recipient
}
