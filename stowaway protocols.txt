All messages use "#### STOWAWAY #### (maybe some meme about the version or linking the github)" now.
All messages attach stowaway.json
NOTE: encrypted is encrypted.  Clearly.  But I need to write about what's in there.

SENDING A MESSAGE:
json:
{
	type: 'channel_message',
	level: (can be 'public', or 'trusted')
	encrypted: the encrypted message itself
}

then when message recieved:
1. get stowaway.json
2. see if type == message
3. attempt to decrypte encrypted
4. if successful:
  a. verify message signature (if not verified add a warning -- protects against token compromise)
  b. display message
  c. if old key in fingerprint respond with current key provenance protocol from fingerprinted key


HANDSHAKE REQUEST:
json:
{
	type: 'handshake_request',
	publicKey: armored public key
	revocations: [
		revokingKey0, (can get the fingerprint of the original key from it)
		revokingKey1, (can get the fingerprint of the original key from it)
		...
		revokingKeyN, (can get the fingerprint of the original key from it)
	]
}

HANDHSAKE RESPONSE:
json:
{
	type: 'handhsake_response'
	publicKey: armored public key
	revocations: [
		revokingKey0, (can get the fingerprint of the original key from it)
		revokingKey1, (can get the fingerprint of the original key from it)
		...
		revokingKeyN, (can get the fingerprint of the original key from it)
	]
}

then when message recieved
1. get attached json & check type
2. old handhsake protocol with publicKey value

KEY SIGNATURE:
NOTE: signer doesn't update his own keys, only after receiving KEY UPDATE does anyone (aside from recipient) update their public keys
json:
{
	type: 'signed_key'
	recipient: snowflake of intended recipient
	publicKey: signed key
}

recipient still checks if fingerprints match, and if they do (1) update then:

KEY UPDATE (send this to all known channels):
json:
{
	type: 'key_update'
	publicKey: update public key
}
again, perform the fingerprint check then use update.  It gracefully merges keys if they have the same fingerprint.
