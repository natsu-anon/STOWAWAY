All messages use "#### STOWAWAY #### (maybe some meme about the version or linking the github)" now.
All messages attach stowaway.json
NOTE: encrypted is encrypted.  Clearly.  But I need to write about what's in there.

ALL HAVE A VERSION KEY & VALUE FOR VERSIONING (to allow for backwards compatibility)

SENDING A MESSAGE:
json:
{
	type: 'channel_message',
	public: true/false -- if false only sends message to recipients whose key you HAVE signed o.w. everyone in the channel
	encrypted: the encrypted message itself
}

then when message recieved:
1. get stowaway.json
2. see if type == message
3. attempt to decrypte encrypted
4. if successful:
  a. verify message signature (if not verified add a warning -- protects against token compromise)
  b. display message
  c. if old key in fingerprint respond with current key provenance protocol from fingerprinted key


HANDSHAKE:
json:
{
	type: 'handshake',
	respond: true/false,
	publicKey: armored public key
	revocations: [
		revokingKey0, (can get the fingerprint of the original key from it)
		revokingKey1, (can get the fingerprint of the original key from it)
		...
		revokingKeyN, (can get the fingerprint of the original key from it)
	]
}

then when message recieved
1. get attached json & check type
2. old handhsake protocol with publicKey value

KEY SIGNATURE:
NOTE: signer doesn't update his own keys, only after receiving KEY UPDATE does anyone (aside from recipient) update their public keys
json:
{
	type: 'signed_key'
	recipient: snowflake (discord id) of intended recipient
	publicKey: signed key
}

recipient still checks if fingerprints match, and if they do (1) update then:

KEY UPDATE (send this to all known channels):
json:
{
	type: 'key_update'
	publicKey: update public key
}
again, perform the fingerprint check then use update.  It gracefully merges keys if they have the same fingerprint.

REVOCATION (send this to all known channels upon key revocation):
json:
{
	revocation: revokingKey
	publicKey: new publicKey
}
